/*----------------------------------------------------------------------------*/
/* Copyright (c) 2019 FIRST. All Rights Reserved.                             */
/* Open Source Software - may be modified and shared by FRC teams. The code   */
/* must be accompanied by the FIRST BSD license file in the root directory of */
/* the project.                                                               */
/*----------------------------------------------------------------------------*/

package frc.robot.subsystems;

import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;
import frc.robot.Libraries.PIDController;

public class Shooter extends SubsystemBase {

private double flywheelSpeed, topflywheelspeed; // flywheelspeed refers to the bottom flywheel, not both. I didnt bother changing that variable because im lazy
private NetworkTable Shooter = NetworkTableInstance.getDefault().getTable("Shooter");

private PIDController VControlTop;
private PIDController VControlBottom;

private WPI_TalonSRX TopShooter = new WPI_TalonSRX(Constants.Shoot1MotorPort);
private WPI_TalonSRX BottomShooter = new WPI_TalonSRX(Constants.Shoot2MotorPort);

private double topShooterValue = 0;
private double bottomShooterValue = 0;

  /*
   * Creates a new Shooter.
   */
  public Shooter() {

    /* 
     Initializing encoders built into the motors, this file editiuon is to be adding a second
     encodor to the top flywheel of the shooter
     */
    BottomShooter.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, Constants.kPIDLoopIdx, Constants.kTimeoutMs);
    BottomShooter.setSensorPhase(true);
    BottomShooter.configFeedbackNotContinuous(true, Constants.kTimeoutMs);
    BottomShooter.setInverted(true);
    
    TopShooter.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative, Constants.kPIDLoopIdx, Constants.kTimeoutMs);
    TopShooter.setSensorPhase(true);
    TopShooter.configFeedbackNotContinuous(true, Constants.kTimeoutMs);
    TopShooter.setInverted(true);

    TopShooter.setInverted(true);
    BottomShooter.setInverted(true);


    VControlTop = new PIDController(0.00001, 0, .00001, 0);
    VControlBottom = new PIDController(0.00001, 0, .00001, 0);

    VControlTop.setTarget(Constants.DesiredFlyWheelSpeed);
    VControlBottom.setTolerance(0);

  }


  /*  I have edited this file so that each motor has a seperate encoder and will not communicate thier values to eachother until
  they are checked by the boolean to give the all-clear to fire. Hopefully this will work, if not then.... it will work. hopefully
  if not than its just a dumb issue with syntax or spelling.*/


  @Override 
  public void periodic() {
    topflywheelspeed = TopShooter.getSelectedSensorVelocity();
    flywheelSpeed = BottomShooter.getSelectedSensorVelocity();

    SmartDashboard.putNumber("Flyweel Speed Offset", getFlywheelOffset());
    SmartDashboard.putNumber("Bottom FlyWheel Speed", flywheelSpeed);
    SmartDashboard.putNumber("Top FlyWheel Speed", topflywheelspeed);
    
   
    // This method will be called once per scheduler run
  }
  /**
  * Will trigger the robot to run both shooting motors
  */
 public double getFlywheelOffset() {
  double Error = topflywheelspeed - flywheelSpeed;
  return Error;
 }

 public double checkSpeedValue() {
   double finalSpeed = flywheelSpeed;
   return finalSpeed;
 }

 public void Shoot() { 
  topShooterValue = -1;
  bottomShooterValue = -1;

  TopShooter.set(-1);
  BottomShooter.set(-1);
 }


/* Will change the power of the flywheel according to the speeds the encoders measure.
Ive edited this to check the values for each individual motor instead of just the bottom one */ 
 public void ControlledShoot() {
      VControlTop.setInput(topflywheelspeed); // Updated to top
      VControlBottom.setInput(flywheelSpeed);

   TopShooter.set(-VControlTop.calculate(1,-1) -.88); // Updated to top
   BottomShooter.set(-VControlBottom.calculate(1,-1) -.88);

   topShooterValue = (-VControlTop.calculate(1,-1) -.88);
   bottomShooterValue = (-VControlBottom.calculate(1,-1) -.88);

 }
   /* This section will check if each flywheel is travelling fast enough to shoot
  It must be returned in a boolean. The booleans are generated by the median speed of
  both flywheels (subject to change maybe) */

  public void SingleEncoderControlledShoot() {
    VControlBottom.setInput(flywheelSpeed);

    TopShooter.set(-VControlBottom.calculate(1,-1) -.88);
    BottomShooter.set(-VControlBottom.calculate(1, -1) -.88);

    topShooterValue = (-VControlBottom.calculate(1,-1) -.88);
    bottomShooterValue = (-VControlBottom.calculate(1,-1) -.88);
  }

 public Boolean FastEnough() {
   return checkSpeedValue() >= Constants.DesiredFlyWheelSpeed - 500;
 }
 public Boolean TooSlow() {
   return checkSpeedValue() <= Constants.DesiredFlyWheelSpeed - 500;
 }



 /**
  * Will end the shooting
  */
 public void StopShoot() {
  topShooterValue = 0;
  bottomShooterValue = 0;

  TopShooter.set(0);
  BottomShooter.set(0);
 }

 public double grabTopShooter(){return topShooterValue;}
 public double grabBottomShooter(){return bottomShooterValue;}
}